<?xml version="1.0"?>
<!--
  Licensed to the Apache Software Foundation (ASF) under one or more
  contributor license agreements.  See the NOTICE file distributed with
  this work for additional information regarding copyright ownership.
  The ASF licenses this file to You under the Apache License, Version 2.0
  (the "License"); you may not use this file except in compliance with
  the License.  You may obtain a copy of the License at

       http://www.apache.org/licenses/LICENSE-2.0

  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an "AS IS" BASIS,
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  See the License for the specific language governing permissions and
  limitations under the License.
-->
<document>
  <properties>
    <author email="christophe.lombart@gmail.com">Christophe Lombart</author>
    <title>Jackrabbit OCM : the Object Content Manager</title>
  </properties>
  <body>
     <section name="Jackrabbit OCM">
      <subsection name="The Object Content Manager Component">
      <p>
	The main component in the OCM framework is the ObjectContentManager. It converts an object graph into JCR nodes and properties and vice versa. The ObjectContentManager is always associated with a JCR Session. It is used to retrieve, create, update and delete objects from a JCR content repository. Usually there is one ObjectContentManager per user session.
      </p>
      <p>
       This page describes how an ObjectManager is working and how it can be initialised in your applications.
      </p>
      </subsection>
      <subsection name="How does the Object Content Manager work ?">
        <p>
	Thanks to a Mapping Descriptor, the ObjectContentManager is able to use the appropriate mapping strategy for each persistent object (pojo). The Mapping Descriptor contains one Class Descriptor per persistent class. Each Class Descriptor contains mapping information for the corresponding class attributes.
        </p>
	<p>
	In point of view implementation, the Mappring Descriptor is an java object injected into the ObjectContentManager (see the interface org.apache.jackrabbit.ocm.mapper.Mapper). Right now,there are 2 different Mapping Descriptor implementations:		
	<ul>
		<li>
		Annotation : each persistent object is annoted in order to provide to the ObjectContentManager all the required information on its mapping strategy (see the class org.apache.jackrabbit.ocm.mapper.impl.annotation.AnnotationMapperImpl). 
		</li>
		<li>
		XML configuration file : the mapping class descriptors are defined in one or more XML config files used by the ObjectContentManager when it is instantiated (see the class org.apache.jackrabbit.ocm.mapper.impl.digester.DigesterMapperImpl). This XML file contains the different class descriptors.
		</li>
	</ul>
	</p>
	<p>For a business developer, it is not necessary to know how the ObjectContent Manager is using the Class Descriptors. He has to make only a choice between annoted classes or one or more XML files. </p>
        </subsection>
	<subsection name="How does an object is persisted into a JCR repository ?">
        <p>
          In all cases, a persistent object (a pojo) is mapped into a JCR node and its fields are mapped into subnodes or properties depending on their types.
        </p>
	<p>
		There are 4 "field types":
	</p>
	
        <dl>
          <dt>Atomic fields</dt>
          <dd>
            Primitive data types and simple objects (String, Long,
            Double, ...) . Those fields are mapped into JCR properties.
          </dd>
          <dt>Bean fields</dt>
          <dd>
            One class can contain an 1..1 association to another bean.
            In this case, the field is a custom object. Those fields
            are mapped into JCR subnodes or a referenced node.
          </dd>
          <dt>Collection fields</dt>
          <dd>
            One class can contain an 1..n association to a collection of
            beans (or Map). Those fields are mapped into a collection of
            JCR subnodes or a collection of referenced nodes. It is also possible to map a java collection into a multivalue property.
          </dd>
        </dl>
        <p>
          The Mapping descriptor contains also information on inheritances, interface mapping strategy, lazy loading,
          custom converter, cache strategy, etc.
        </p>
      </subsection>


      <subsection name="Basic setup (with annoted persistent classes)">
	      <p>
		      When you start your application, you need the following code
		      to initialize correctly the Object Content Manager.
	      </p>
	      <source>
import javax.jcr.Session;
import javax.jcr.Repository;
		      
import org.apache.jackrabbit.ocm.manager.impl.ObjectContentManagerImpl;
import org.apache.jackrabbit.ocm.mapper.Mapper;
import org.apache.jackrabbit.ocm.mapper.impl.annotation.AnnotationMapperImpl;

		      
// 1. Instantiate a JCR session
Repository repository = ...;
Session session = repository.login(...);
		      
// 2. Register the different persistent classes
List classes = new ArrayList();
classes.add(MyContent.class); // Call this method for each persistent class

				      
// 3. Instantiate the object manager
Mapper mapper = new AnnotationMapperImpl(classes);
ocm = new ObjectContentManagerImpl(session, mapper);

		      
	      </source>
      </subsection>

      <subsection name="Basic setup (with an XML Mapping Descriptor)">
        <p>
          When you start your application, you need the following code
          to initialize correctly the Object Content Manager.
        </p>
        <source>
import javax.jcr.Session;
import javax.jcr.Repository;

import org.apache.jackrabbit.ocm.mapper.Mapper;
import org.apache.jackrabbit.ocm.mapper.impl.digester.DigesterMapperImpl;
import org.apache.jackrabbit.ocm.manager.ObjectContentManager;
import org.apache.jackrabbit.ocm.manager.impl.ObjectContentManagerImpl;
import org.apache.jackrabbit.ocm.manager.atomictypeconverter.AtomicTypeConverterProvider;
import org.apache.jackrabbit.ocm.manager.atomictypeconverter.impl.DefaultAtomicTypeConverterProvider;
import org.apache.jackrabbit.ocm.manager.objectconverter.ObjectConverter;
import org.apache.jackrabbit.ocm.manager.objectconverter.impl.ObjectConverterImpl;
import org.apache.jackrabbit.ocm.query.QueryManager;
import org.apache.jackrabbit.ocm.query.impl.QueryManagerImpl;

// 1. Instantiate a JCR session
Repository repository = ...;
Session session = repository.login(...);

// 2. Specify the different mapping files
String[] files = {
      "./src/test-config/jcrmapping.xml",
      "./src/test-config/jcrmapping-atomic.xml",
      "./src/test-config/jcrmapping-beandescriptor.xml"
  };

// 3. Instantiate the object manager
ObjectContentManager ocm = new ObjectContentManagerImpl(session, files);

</source>
      </subsection>

      <subsection name="API Overview">
        <p>
          With the current Object Manager API, it is possible to:
        </p>
        <ul>
          <li>
            Manage the object life cycle (insert, update, delete, retrieve).
            See <a href="api/basic-operations.html">Basic operations</a>.
          </li>
          <li>
            Search single object or collections with criteria.
            See <a href="api/search.html">Search</a>.
          </li>
          <li>
            Lock objects.
            See <a href="api/locking.html">Locking</a>.
          </li>
          <li>
            Manage versions (check int, check out, create a new version,
            show history).
            See <a href="api/versionning.html">Versioning</a>.
          </li>
        </ul>
        <p>
          We plan to add other features in a future release.
        </p>
      </subsection>
    </section>
  </body>
</document>
